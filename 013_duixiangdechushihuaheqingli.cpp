#include <iostream>
using namespace std;

// 构造和析构函数规则
class Person{
	public:
		// 构造函数 进行实例的初始化
		// 1. 没有返回值 也不用写void
		// 2. 函数名与类名相同
		// 3. 构造函数可以有参数，因此可以重载
		// 4. 在创建对象的时候被调用，且只会被调用一次
		Person(){
			cout << "Person 构造函数被调用" << endl;
		}
		
		// 析构函数 进行清理操作
		// 1. 没有返回值，也不用写void
		// 2. 函数名与类型相同，在名称前写~
		// 3. 析构函数不可以有参数，因此不可以被重载
		// 4. 在对象销毁前使用，且只会被调用一次
		~Person(){
			cout << "Person 析构函数被调用" << endl;
		}
	
	
	
};

// 构造函数和析构函数的生命周期展示
void test01(){
	Person p;
}

// 构造函数的分类和调用
class Person1{
	public:
		//! 构造函数按照参数个数，分为：无参构造函数和有参构造函数
		// 无参构造函数（默认构造函数）
		Person1(){
			cout << "Person1 无参构造函数被调用" << endl;
		}
		// 有参构造函数
		Person1(int age){
			p_age = age; // 有参构造函数可以传递参数，对类中的属性进行初始化
			cout << "Person1 有参构造函数被调用" << endl;
		}
		
		//! 按照类型分类：普通构造函数和拷贝构造函数
		// 拷贝构造函数，除了传递参数为对象的构造函数，其他都叫普通构造函数
		// 顾名思义，就是将一个对象的所有属性和方法都复制一遍成为一个新的对象，就是拷贝构造函数
		// 1. 因此传入的参数是一个对象
		// 2. 拷贝过程中不能够修改原本对象的内容，因此增加const
		// 3. 使用引用传递参数
		Person1(const Person1 &p){
			p_age = p.p_age; // 通过传入的对象来对当前要构造的对象属性进行初始化
			cout << "Person1 拷贝构造函数被调用" << endl;
		}
		
		~Person1(){
			cout << "Person1 析构函数被调用" << endl;
		}
		
		// 
		int p_age;
};

// 构造函数的调用
void test02(){
	//! 括号法
	/*
	Person1 p0; // 默认构造函数调用
	Person1 p1(10); // 有参构造函数被调用
	Person1 p2(p1); // 拷贝构造函数被调用
	*/
	//cout << "p1的年龄：" << p1.age << endl;
	//cout << "p2的年龄：" << p2.age << endl; // 通过拷贝构造函数将p1中的属性完全复制了一份给p2，因此p2的age属性也是10
	
	//! 要注意的是 当使用默认构造函数的时候，不要再最后增加小括号
	// Person1 p(); // 这会使得编译器认为这一行代码是一个函数声明 不会去创建对象
	
	//! 显示法
	/*
	Person1 p0; // 无参构造函数调用
	Person1 p1 = Person1(10); // 有参构造函数
	Person1 p2 = Person1(p2); // 拷贝构造函数
	*/
	
	//!Person1(10); // 等号右边的内容 叫做匿名对象，特点：当前行执行结束后，系统会立即回收匿名对象
	//cout << "aaa" << endl;
	// 观察到，当86行的匿名对象，在执行输出aaa之前就已经被释放了
	
	//! 要注意，不要使用拷贝构造函数去初始化匿名对象
	// Person1(p2); // 这个在执行的时候，编译器会将小括号去掉，变成 Person1 p2; 认为是一个对象的声明
	// 此时会发现上面已经定义过一个p2了，会报错说p2这个变量名重定义
	
	//! 隐式构造法
	Person1 p = 10; // 有参构造 编译器会自动转化为显示表示法，即 Person1 p = Person1(10)
	Person1 p1 = p; // 拷贝构造
	
	//! 上述写法中，97行隐式构造法只适用于单个参数的对象实例化，如果存在多个参数，则不可以使用隐式构造法
	// 多个参数的时候通常要使用显示构造法
}

void doWork(Person1 p){
	cout << "doWork" << endl;
}

Person1 doWork1(){
	cout << "doWork1" << endl;
	Person1 p;
	// 值返回的时候，会调用拷贝构造函数，因为原本的p是局部变量，在函数执行完之后会被释放
	return p;
}

// 拷贝构造函数的使用时机
void test03(){
	// 1. 使用一个已经创建好的对象去初始化一个新对象
	Person1 p(10); // 有参构造函数
	//Person1 p1(p); // 拷贝构造函数
	
	cout << "====" << endl;
	
	// 2. 值传递的方式个函数传值
	// 值传递相当于也是创建了一个副本， 实参在传递给形参的时候，会调用拷贝构造函数
	doWork(p);
	cout << "====" << endl;
	
	// 3. 值方式返回局部对象
	Person1 p2 = doWork1();
}

int main(){
	
	// 对象的初始化和清理
	/*
	 * 对象的初始化和清理也是两个非常重要的安全问题
	 * 	一个对象或者变量没有初始状态，对其使用后果是未知
	 * 	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题
	 * */
	// 1.构造函数(初始化)和析构函数(清理)  
	// 如果不手动编写，则由编译器自动构造，但是编译器提供的构造函数和析构函数是空实现（即函数体是空的）
	//! 编译器会默认给类添加三个构造函数，默认的构造函数（无参，函数体为空），默认的析构函数（无参，函数体为空），默认的拷贝函数（对属性值进行拷贝）
	// 构造函数的调用规则：
	/*
	 * 如果用户定义了有参构造函数，编译器就不再提供默认的无参构造，但是会提供默认的拷贝构造
	 * 如果用户定义了拷贝构造函数，编译器就不会再提供其他的构造函数
	 * */
	
	//! 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用
	// 语法：类名(){}
	/*
	 * 1. 构造函数，没有返回值也不写void
	 * 2. 函数名称与类名相同
	 * 3. 构造函数[可以有参数]，因此[可以发生重载]
	 * 4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次
	 * */
	test01();
	// 并没有调用任何类中的函数，但是构造函数依旧被执行了
	// 对象被创建在函数中，保存在栈上，在函数执行完之后，就都会被释放，即对象被销毁，会自动调用析构函数
	 
	cout << "--------------" << endl;
	
	//! 构造函数的分类
	// 按照是否与参数，分为：有参构造函数和无参构造函数
	// 按照类型分为：		   普通构造函数和拷贝构造函数
	 
	// 三种调用方式：括号法, 显示法, 隐式转换法
	test02();
	
	cout << "--------------" << endl;
	
	//! 拷贝构造函数的调用时机
	/*
	 * 1. 使用一个已经创建好的对象来初始化一个新对象
	 * 2. 使用值传递的方式给函数的参数传值
	 * 3. 以值方式返回局部对象
	 * */
	test03();
	 
	 
	 
	 
	 
	//! 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。
	//语法：~类名(){}
	/*
	 *  1. 析构函数，没有返回值也不写void
	 *	2. 函数名称与类名相同,在名称前加上符号  ~
	 *	3. 析构函数[不可以有参数]，因此[不可以发生重载]
	 *  4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次
	 * */
	
	
    system("pause");
    return 0;
}
